<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Clasificación de Basura Inteligente</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>

    <div class="container">
        <h1>♻️ Cámara en Vivo</h1>
        <div class="video-container">
            <img src="{{ url_for('video_feed') }}" alt="Video en vivo de la cámara">
        </div>
    </div>

    <div class="container">
        <h2>Historial de Clasificación</h2>
        <ul id="history-list">
        </ul>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {

        const historyList = document.getElementById('history-list');
        let lastKnownId = 0;
        let isInitialLoad = true; // Flag para controlar la carga inicial

        /**
         * Reproduce un texto usando la API de Síntesis de Voz del navegador.
         */
        function speak(text) {
            if (!('speechSynthesis' in window)) {
                console.warn("La API de Speech Synthesis no es compatible con este navegador.");
                return;
            }
            // Cancelar cualquier locución anterior para dar prioridad a la nueva
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'es-ES';
            utterance.rate = 1.1;
            window.speechSynthesis.speak(utterance);
        }

        function createHistoryElement(record) {
            const item = document.createElement('li');
            item.className = 'history-item';
            item.id = `record-${record.id}`;

            const material = record.material || 'desconocido';
            const iconChar = material.charAt(0).toUpperCase();

            const date = new Date(record.fecha);
            const formattedTime = date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

            item.innerHTML = `
                <div class="material-icon material-${material.toLowerCase()}">${iconChar}</div>
                <div class="info">
                    <strong>${material.replace('_', ' ')}</strong>
                    <span>- ${record.respuesta_hablada}</span>
                </div>
                <div class="timestamp">${formattedTime}</div>
            `;
            return item;
        }

        /**
         * Busca nuevos registros en el historial y actualiza la interfaz.
         */
        async function fetchAndUpdateHistory() {
            try {
                const response = await fetch('/history');
                if (!response.ok) {
                    console.error("Error al obtener el historial.");
                    return;
                }
                const records = await response.json();

                if (records.length === 0) {
                    return;
                }

                // En la carga inicial, establecer el ID más reciente para no reproducir el audio antiguo.
                if (isInitialLoad) {
                    lastKnownId = records[0].id;
                    isInitialLoad = false;
                    // Cargar toda la historia sin reproducir audio
                    historyList.innerHTML = '';
                    records.forEach(record => {
                        const element = createHistoryElement(record);
                        historyList.appendChild(element);
                    });
                    return; // Salir en la primera carga
                }

                const latestRecord = records[0];
                if (latestRecord.id > lastKnownId) {
                    console.log(`Nuevo registro detectado: ID ${latestRecord.id}`);
                    lastKnownId = latestRecord.id;

                    // Añadir solo el nuevo elemento al principio de la lista
                    const newElement = createHistoryElement(latestRecord);
                    historyList.insertBefore(newElement, historyList.firstChild);

                    // Limitar el historial a, por ejemplo, 20 elementos
                    while (historyList.children.length > 20) {
                        historyList.removeChild(historyList.lastChild);
                    }

                    // Aplicar animación al nuevo elemento
                    newElement.classList.add('new-record');
                    setTimeout(() => {
                        newElement.classList.remove('new-record');
                    }, 1500);
                }
            } catch (error) {
                console.error('Error en el proceso de actualización del historial:', error);
            }
        }

        /**
         * Busca nuevos mensajes de voz del backend y los reproduce.
         */
        async function fetchAndSpeakMessages() {
            try {
                const response = await fetch('/get_messages');
                if (!response.ok) {
                    console.error("Error al obtener mensajes de voz.");
                    return;
                }
                const messages = await response.json();

                // Reproducir cada mensaje en orden
                messages.forEach(text => {
                    if (text) {
                        console.log("Reproduciendo mensaje:", text);
                        speak(text);
                    }
                });
            } catch (error) {
                console.error('Error al obtener mensajes de voz:', error);
            }
        }

        // --- Ciclos de Actualización ---
        fetchAndUpdateHistory(); // Carga inicial
        setInterval(fetchAndUpdateHistory, 2000); // Actualiza el historial
        setInterval(fetchAndSpeakMessages, 1500); // Busca nuevos mensajes de voz

    });
    </script>

</body>
</html>
